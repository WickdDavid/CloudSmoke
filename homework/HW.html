<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>HomeWork#1</title>
    <script type="x-shader/x-vertex" id="vshader">
        attribute vec3 coords;
        uniform mat4 modelview;
        uniform mat4 projection;
        attribute vec3 normal;
        uniform mat3 normalMatrix; 
        varying vec3 v_Normal;
        uniform vec4 color; 
        varying vec4 vColor;
        //varying vec3 v_lightDirection;
        varying vec3 v_Position;
        varying vec4 v_Color;
        void main() { 
                 vec4 coords = vec4(coords,1.0);
                 vec4 transformedVertex = modelview * coords; 
                 gl_Position = projection * transformedVertex; 
                 vec3 unitNormal = normalize(normalMatrix*normal); 
                 v_Position = vec3(modelview * coords * projection);
                 float multiplier = abs(unitNormal.z); 
                 v_Normal = normalize(vec3(normalMatrix * normal));
                 vColor = vec4( multiplier*color.r, multiplier*color.g, multiplier*color.b, color.a ); 
                 v_Color= vColor;
        }
    </script>
    <script type="x-shader/x-fragment" id="fshaderOLD">
        precision mediump float; varying vec4 vColor; void main() { gl_FragColor = vColor; }
    </script>
    <script type="x-shader/x-fragment" id="fshader">
        #ifdef GL_ES
        precision mediump float;
        #endif
        uniform vec3 u_LightColor; // Light color
        uniform vec3 u_LightPosition; // Position of the light source
        uniform vec3 u_AmbientLight; // Ambient light color
        varying vec3 v_Normal;
        varying vec3 v_Position;
        uniform vec3 u_LightDirection;
        uniform vec3 u_ViewerPosition;
        uniform vec3 u_SpecularColor;
        uniform float u_Exponent;
        varying vec4 v_Color;
        void main() {
        // Normalize the normal because it is interpolated and not 1.0 in length any more
          vec3 normal = normalize(v_Normal);
        // Calculate the light direction and make its length 1.
          //vec3 lightDirection = normalize(u_LightPosition - v_Position);
          vec3 lightDirection=u_LightDirection;
          vec3 viewerDirection = normalize(u_ViewerPosition - v_Position);
          vec3 reflectDirection = normalize(reflect(lightDirection, normal));
        // The dot product of the light direction and the orientation of a surface (the normal)
          float nDotL = max(dot(lightDirection, normal), 0.0);
          float rDotV = pow(max(dot(reflectDirection, viewerDirection), 0.0),u_Exponent);
        // Calculate the final color from diffuse reflection and ambient reflection
          vec3 diffuse = u_LightColor * v_Color.rgb * nDotL;
          vec3 specular = u_LightColor * u_SpecularColor.rgb * rDotV;
          vec3 ambient = u_AmbientLight * v_Color.rgb;
          gl_FragColor = vec4(diffuse + ambient  + specular, v_Color.a);
        }
    </script>    
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript" src="basic-objects.js"></script>
    <script type="text/javascript" src="simple-rotator.js"></script>
    <script type="text/javascript">
    "use strict";

    var gl; // The webgl context.

    var VSHADER_SOURCE =
        'attribute vec4 a_Position;\n' +
        'attribute vec4 a_Color;\n' +
        'attribute vec4 a_Normal;\n' +
        'uniform mat4 u_MvpMatrix;\n' +
        'uniform mat4 u_ModelMatrix;\n' + // Model matrix
        'uniform mat4 u_NormalMatrix;\n' + // Transformation matrix of the normal
        'varying vec4 v_Color;\n' +
        'varying vec3 v_Normal;\n' +
        'varying vec3 v_Position;\n' +
        'void main() {\n' +
        '  gl_Position = u_MvpMatrix * a_Position;\n' +
        // Calculate the vertex position in the world coordinate
        '  v_Position = vec3(u_ModelMatrix * a_Position);\n' +
        '  v_Normal = normalize(vec3(u_NormalMatrix * a_Normal));\n' +
        '  v_Color = a_Color;\n' +
        '}\n';

    var FSHADER_SOURCE =
        '#ifdef GL_ES\n' +
        'precision mediump float;\n' +
        '#endif\n' +
        'uniform vec3 u_LightColor;\n' + // Light color
        'uniform vec3 u_LightPosition;\n' + // Position of the light source
        'uniform vec3 u_AmbientLight;\n' + // Ambient light color
        'varying vec3 v_Normal;\n' +
        'varying vec3 v_Position;\n' +
        'uniform vec3 u_ViewerPosition;\n' +
        'uniform vec3 u_SpecularColor;\n' +
        'uniform float u_Exponent;\n' +
        'varying vec4 v_Color;\n' +
        'void main() {\n' +
        // Normalize the normal because it is interpolated and not 1.0 in length any more
        '  vec3 normal = normalize(v_Normal);\n' +
        // Calculate the light direction and make its length 1.
        '  vec3 lightDirection = normalize(u_LightPosition - v_Position);\n' +
        '  vec3 viewerDirection = normalize(u_ViewerPosition - v_Position);\n' +
        '  vec3 reflectDirection = normalize(reflect(lightDirection, normal));\n' +
        // The dot product of the light direction and the orientation of a surface (the normal)
        '  float nDotL = max(dot(lightDirection, normal), 0.0);\n' +
        '  float rDotV = pow(max(dot(reflectDirection, viewerDirection), 0.0),u_Exponent);\n' +
        // Calculate the final color from diffuse reflection and ambient reflection
        '  vec3 diffuse = u_LightColor * v_Color.rgb * nDotL;\n' +
        '  vec3 specular = u_LightColor * u_SpecularColor.rgb * rDotV;\n' +
        '  vec3 ambient = u_AmbientLight * v_Color.rgb;\n' +
        '  gl_FragColor = vec4(diffuse + ambient + specular, v_Color.a);\n' +
        '}\n';



    var aCoords; // Location of the coords attribute variable in the shader program.
    var aCoordsBuffer; // Buffer to hold coords.
    var aNormal; // Location of the normal uniform in the shader program.
    var aNormalBuffer; // Buffer to hold normal vectors.
    var indexBuffer; // Buffer to hold indices for gl.drawElements
    var uColor; // Location of the color uniform variable in the shader program.
    var uProjection; // Location of the projection uniform matrix in the shader program.
    var uModelview; // Location of the modelview unifirm matrix in the shader program.
    var uNormalMatrix; // Location of the normalMatrix uniform matrix in the shader program.

    var projection = mat4.create(); // projection matrix
    var modelview = mat4.create(); // modelview matrix
    var normalMatrix = mat3.create(); // matrix, derived from modelview matrix, for transforming normal vectors

    var rotator; // A SimpleRotator object to enable rotation by mouse dragging.

    var frameNumber = 0; // frame number during animation (actually only goes up by 0.5 per frame)

    var torus, sphere, cone, cylinder, disk, ring, cube; // basic objects, created using function createModel

    var show = 1; // When this variable is 1, the entire scene is drawn; when it is 2, only the car is shown

    var modelview; // The current modelview matrix
    var matrixStack = []; // A stack of matrices for implementing hierarchical graphics.

    var currentColor = [1, 1, 1, 1]; // The current drawing color; objects are rendered using this color.


    /**
     * Draws the image, which consists of either the "world" or a closeup of the "car".
     */
    function draw() {
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        //changeLightLocation();

        mat4.perspective(projection, Math.PI / 4, 1, 1, 50); //assigns to the matrix projection the transformation with frustum
        //defined by an eye angle of 45 degrees (pi/4), ratio of width/height
        // of 1, near plane 1 and far plane 50
        gl.uniformMatrix4fv(uProjection, false, projection); //assigns the value of the matrix projection to the uniform matrix uProjection

        modelview = rotator.getViewMatrix(); //computes the modelview from the position of the rotator
        mat3.normalFromMat4(normalMatrix, modelview); //computes the normalMatrix (used to multiply the normals) from the modelview

        /*
        pushMatrix();
        mat4.translate(modelview,modelview,[0,4,0]);
        cube.render();
        popMatrix();*/

        if (show == 1)
            world();
        else
            car();
    }

    /**
     * Draws a "world" consisting of a disk holding some trees and a road, and a car that
     * drives along the road.  A tree in the middle grows from frame 0 to frame 1000.
     */
    function world() {
        pushMatrix(); //creates a copy of the current top matrix of the matrix stack
        mat4.translate(modelview, modelview, [0, -0.05, 0]); //modifies the second parameter (modelview) by multiplying it with
        //the translation matrix with parameters [0,-0.05,0] and assigns the result
        //to the first parameter. In this case, it modifies the modelview.
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [1, 0, 0]); //modifies the second parameter (modelview) by multiplying it with
        //the rotation matrix with parameters (90)/180*Math.PI (angle of 90 degrees) and
        //[1,0,0] (axis of rotation) and assigns the result
        //to the first parameter. In this case, it modifies the modelview.
        currentColor = [0.1, 0.4, 0.1, 1]; //Defines the color
        disk.render(); //Renders the disk
        popMatrix(); //deletes the top matrix of the stack
        pushMatrix();
        currentColor = [0.7, 0.7, 0.8, 1];
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [-1, 0, 0]);
        ring.render();
        popMatrix();
        pushMatrix();
        mat4.rotate(modelview, modelview, -1*(tick)*fact, [0,1,0]);
        mat4.translate(modelview, modelview, [(-r-0.5)*Math.sin(0*fact),0.05,(-r-0.5)*Math.cos(0*fact)]);
        bicycle();
        popMatrix();

        pushMatrix();
        mat4.rotate(modelview, modelview, -1*tickAngle*fact, [0,1,0]);
        mat4.translate(modelview, modelview, [-r*Math.sin(0*fact),0.05,-r*Math.cos(0*fact)]);
        bicycle();
        popMatrix();

        move_bicycle();




        pushMatrix();
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [-1, 0, 0]);
        mat4.translate(modelview, modelview, [2.1, 0, 0]);
        mat4.scale(modelview, modelview, [0.5, 0.5, 0.5]);
        tree();
        popMatrix();

        pushMatrix();
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [-1, 0, 0]);
        mat4.translate(modelview, modelview, [-1.67, -0.7, 0]);
        mat4.scale(modelview, modelview, [0.5, 0.5, 0.5]);
        tree();
        popMatrix();

        pushMatrix();
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [-1, 0, 0]);
        mat4.translate(modelview, modelview, [0, 1.63, 0]);
        mat4.scale(modelview, modelview, [0.5, 0.5, 0.5]);
        tree();
        popMatrix();

        pushMatrix();
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [-1, 0, 0]);
        mat4.translate(modelview, modelview, [0, -1.9, 0]);
        mat4.scale(modelview, modelview, [0.5, 0.5, 0.5]);
        tree();
        popMatrix();








        popMatrix();
    }

    /**
     * Draws a tree consisting of a green cone with a brown cylinder for a trunk.
     */
    function tree() {
        pushMatrix();
        pushMatrix();
        currentColor = [0.5, 0.3, 0.1, 1];
        cylinder.render();
        popMatrix();
        pushMatrix();
        currentColor = [0, 0.8, 0, 1];
        cone.render();
        popMatrix();
        popMatrix();
    }

    /**
     * Draws a bicycle consisting of a (simplified) body, two wheels 
     * and a light positioned in front.
     */
    
     var tick=90;
     var tickAngle=90;
     var r=4;
     var fact = Math.PI/180;


     function move_bicycle() {

        if(tick==359) tick=0;
        else tick++;
        if(tickAngle>=359) tickAngle=0;
        else tickAngle+=5;

     }   



    function bicycle() {


        var cylinderForBicycle = createModel(uvCylinder(0.02, 0.20), [0, 0, 0]);
        var cylinderForBicycle2 = createModel(uvCylinder(0.02, 0.50), [0, 0, 0]);
        var cylinderForBicycle3 = createModel(uvCylinder(0.02, 0.30), [0, 0, 0]);
        var cylinderForBicycle4 = createModel(uvCylinder(0.02, 0.35), [0, 0, 0]);
        var cylinderForBicycle5 = createModel(uvCylinder(0.02, 0.30), [0, 0, 0]);
        var cylinderForBicycle6 = createModel(uvCylinder(0.02, 0.30), [0, 0, 0]);
        var cylinderForBicycle7 = createModel(uvCylinder(0.02, 0.40), [0, 0, 0]);
        var saddle = createModel(uvCone(0.10, 0.20), [0, 0, 0]);



        pushMatrix();
        mat4.translate(modelview, modelview, [0, 0, 0]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [-1, 0, 0]);
        wheel();
        popMatrix();
        pushMatrix();
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [-1, 0, 0]);
        mat4.translate(modelview, modelview, [0.8, 0, 0]);
        wheel();
        popMatrix();
        pushMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [0.28, 0.27, 0]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [0, 1, 0]);
        currentColor = [0.255, 0.51, 0.51, 1];
        cylinderForBicycle.render();
        popMatrix();
        popMatrix();
        pushMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [0.55, 0.45, 0]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [1, -1, 0]);
        currentColor = [0.255, 0.51, 0.51, 1];
        cylinderForBicycle2.render();
        popMatrix();
        popMatrix();
        pushMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [0.75, 0.50, 0]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [1, 0, 0]);
        currentColor = [0.255, 0.51, 0.51, 1];
        cylinderForBicycle3.render();
        popMatrix();
        popMatrix();
        pushMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [0.75, 0.65, 0]);
        currentColor = [0, 0, 0, 1];
        cylinderForBicycle4.render();
        popMatrix();
        popMatrix();
        pushMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [0.30, 0.40, 0]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [1, -1, 0.50]);
        currentColor = [0.255, 0.51, 0.51, 1];
        cylinderForBicycle5.render();
        popMatrix();
        popMatrix();
        pushMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [0.5, 0.55, 0]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [0, 1, 0]);
        currentColor = [0.255, 0.51, 0.51, 1];
        cylinderForBicycle6.render();
        popMatrix();
        popMatrix();
        pushMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [0.35, 0.45, 0]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [1, 0, 0]);
        currentColor = [0.255, 0.51, 0.51, 1];
        cylinderForBicycle7.render();
        popMatrix();
        popMatrix();
        pushMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [0.38, 0.65, 0]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [0, 0.5, 0]);
        mat4.scale(modelview, modelview, [1, 0.2, 1]);
        currentColor = [0.0, 0.0, 0.0, 1];
        saddle.render();
        popMatrix();
        popMatrix();


    }

    /**
     * Draw a rotating wheel that consists of a torus to make the wheel.
     */
    function wheel() {
        pushMatrix();
        currentColor = [0, 0, 0, 1];
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [1, 0, 0]);
        torus.render();
        popMatrix();
    }


    /**
     *  Push a copy of the current modelview matrix onto the matrix stack.
     */
    function pushMatrix() {
        matrixStack.push(mat4.clone(modelview));
    }

    /**
     *  Restore the modelview matrix to a value popped from the matrix stack.
     */
    function popMatrix() {
        modelview = matrixStack.pop();
    }


    /**
     *  Create one of the basic objects.  The modelData holds the data for
     *  an IFS using the structure from basic-objects-IFS.js.  This function
     *  creates VBOs to hold the coordinates, normal vectors, and indices
     *  from the IFS, and it loads the data into those buffers.  The function
     *  creates a new object whose properties are the identifies of the
     *  VBOs.  The new object also has a function, render(), that can be called to
     *  render the object, using all the data from the buffers.  That object
     *  is returned as the value of the function.  (The second parameter,
     *  xtraTranslate, is there because this program was ported from a Java
     *  version where cylinders were created in a different position, with
     *  the base on the xy-plane instead of with their center at the origin.
     *  The xtraTranslate parameter is a 3-vector that is applied as a
     *  translation to the rendered object.  It is used to move the cylinders
     *  into the position expected by the code that was ported from Java.)
     */
    function createModel(modelData, xtraTranslate) {
        var model = {};
        model.coordsBuffer = gl.createBuffer();
        model.normalBuffer = gl.createBuffer();
        model.indexBuffer = gl.createBuffer();
        model.count = modelData.indices.length;
        if (xtraTranslate)
            model.xtraTranslate = xtraTranslate;
        else
            model.xtraTranslate = null;
        gl.bindBuffer(gl.ARRAY_BUFFER, model.coordsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexPositions, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexNormals, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, modelData.indices, gl.STATIC_DRAW);
        model.render = function() { // This function will render the object.
            // Since the buffer from which we are taking the coordinates and normals
            // change each time an object is drawn, we have to use gl.vertexAttribPointer
            // to specify the location of the data. And to do that, we must first
            // bind the buffer that contains the data.  Similarly, we have to
            // bind this object's index buffer before calling gl.drawElements.
            gl.bindBuffer(gl.ARRAY_BUFFER, this.coordsBuffer);
            gl.vertexAttribPointer(aCoords, 3, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
            gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);
            gl.uniform4fv(uColor, currentColor);
            if (this.xtraTranslate) {
                pushMatrix();
                mat4.translate(modelview, modelview, this.xtraTranslate);
            }
            gl.uniformMatrix4fv(uModelview, false, modelview);
            mat3.normalFromMat4(normalMatrix, modelview);
            gl.uniformMatrix3fv(uNormalMatrix, false, normalMatrix);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);
            if (this.xtraTranslate) {
                popMatrix();
            }
        }
        return model;
    }



    /* Creates a program for use in the WebGL context gl, and returns the
     * identifier for that program.  If an error occurs while compiling or
     * linking the program, an exception of type String is thrown.  The error
     * string contains the compilation or linking error.  If no error occurs,
     * the program identifier is the return value of the function.
     */
    function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
        var vsh = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vsh, vertexShaderSource);
        gl.compileShader(vsh);
        if (!gl.getShaderParameter(vsh, gl.COMPILE_STATUS)) {
            throw "Error in vertex shader:  " + gl.getShaderInfoLog(vsh);
        }
        var fsh = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fsh, fragmentShaderSource);
        gl.compileShader(fsh);
        if (!gl.getShaderParameter(fsh, gl.COMPILE_STATUS)) {
            throw "Error in fragment shader:  " + gl.getShaderInfoLog(fsh);
        }
        var prog = gl.createProgram();
        gl.attachShader(prog, vsh);
        gl.attachShader(prog, fsh);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            throw "Link error in program:  " + gl.getProgramInfoLog(prog);
        }
        return prog;
    }


    /* Gets the text content of an HTML element.  This is used
     * to get the shader source from the script elements that contain
     * it.  The parameter should be the id of the script element.
     */
    function getTextContent(elementID) {
        var element = document.getElementById(elementID);
        var fsource = "";
        var node = element.firstChild;
        var str = "";
        while (node) {
            if (node.nodeType == 3) // this is a text node
                str += node.textContent;
            node = node.nextSibling;
        }
        return str;
    }


    //--------------------------------- animation framework ------------------------------

    window.requestAnimationFrame =
        window.requestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        function(callback) {
            setTimeout(function() {
                callback(Date.now());
            }, 1000 / 60);
        }

    var animating = false;

    function frame() {
        if (animating) {
            frameNumber += 0.5;
            draw();
            requestAnimationFrame(frame);
        }

    }

    function setAnimating(run) {
        if (run != animating) {
            animating = run;
            if (animating)
                requestAnimationFrame(frame);
        }
    }

    //-------------------------------------------------------------------------


    var positX = -10;
    var positZ = 0;
    var prog;
    var reverse=false;
    var vel = 0.1;

    function changeLightLocation(){


            var u_LightColor = gl.getUniformLocation(prog, 'u_LightColor');
            var u_SpecularColor = gl.getUniformLocation(prog, 'u_SpecularColor');
            var u_Exponent = gl.getUniformLocation(prog, 'u_Exponent');
            var u_LightPosition = gl.getUniformLocation(prog, 'u_LightPosition');
            var u_LightDirection = gl.getUniformLocation(prog, 'u_LightDirection');
            var u_AmbientLight = gl.getUniformLocation(prog, 'u_AmbientLight');

        // alert("hey "+posit);
            gl.uniform3f(u_LightColor, 1.0, 1.0, 1.0);
  // Set the light direction (in the world coordinate)
            //gl.uniform3f(u_LightPosition, positX,positZ,0);

            gl.uniform3f(u_LightDirection, positX,positZ, 0.0);
  // Set the ambient light
            gl.uniform3f(u_AmbientLight, 0.2, 0.2, 0.2);
  // Set the specular color (white)
            gl.uniform3f(u_SpecularColor, 0.8, 0.8, 0.8);
  // Set the ambient light
            gl.uniform1f(u_Exponent, 5.0);
        
            if(positX>=0 && !reverse){
                positX+=0.1;
                positZ-=0.1;
                if(positX==10) {
                    reverse=true;
                }
            }
            else if(positX<0 && !reverse){
                positX+=0.1;
                positZ+=0.1;
            }

            else if(positX>=0 && reverse){
                positX-=0.1;
                positZ-=0.1;
                
            }
            else{
                positX-=0.1;
                positZ+=0.1;
                if(positX==-10) {
                    reverse=false;
                }
            }
        
        

    }




    function init() {
        try {
            var canvas = document.getElementById("glcanvas");
            gl = canvas.getContext("webgl");
            if (!gl) {
                gl = canvas.getContext("experimental-webgl");
            }
            if (!gl) {
                throw "Could not create WebGL context.";
            }
            var vertexShaderSource = getTextContent("vshader");
            var fragmentShaderSource = getTextContent("fshader");
            //var prog = createProgram(gl, VSHADER_SOURCE, FSHADER_SOURCE);
            prog = createProgram(gl, vertexShaderSource, fragmentShaderSource);

            gl.useProgram(prog);
            aCoords = gl.getAttribLocation(prog, "coords");
            aNormal = gl.getAttribLocation(prog, "normal");
            uModelview = gl.getUniformLocation(prog, "modelview");
            uProjection = gl.getUniformLocation(prog, "projection");
            uColor = gl.getUniformLocation(prog, "color");
            uNormalMatrix = gl.getUniformLocation(prog, "normalMatrix");
            var u_LightColor = gl.getUniformLocation(prog, 'u_LightColor');
            var u_SpecularColor = gl.getUniformLocation(prog, 'u_SpecularColor');
            var u_Exponent = gl.getUniformLocation(prog, 'u_Exponent');
            var u_LightPosition = gl.getUniformLocation(prog, 'u_LightPosition');
            var u_LightDirection = gl.getUniformLocation(prog, 'u_LightDirection');
            var u_AmbientLight = gl.getUniformLocation(prog, 'u_AmbientLight');
           
            if(u_LightPosition==-1){
                alert("FUCK");
            }


            /*var u_ModelMatrix = gl.getUniformLocation(gl.program, 'u_ModelMatrix');
            var u_MvpMatrix = gl.getUniformLocation(gl.program, 'u_MvpMatrix');
            var u_NormalMatrix = gl.getUniformLocation(gl.program, 'u_NormalMatrix');
            var u_LightColor = gl.getUniformLocation(gl.program, 'u_LightColor');
            var u_ViewerPosition = gl.getUniformLocation(gl.program, 'u_ViewerPosition');
            var u_SpecularColor = gl.getUniformLocation(gl.program, 'u_SpecularColor');
            var u_Exponent = gl.getUniformLocation(gl.program, 'u_Exponent');
            var u_LightPosition = gl.getUniformLocation(gl.program, 'u_LightPosition');
            var u_AmbientLight = gl.getUniformLocation(gl.program, 'u_AmbientLight');
            if (!u_ModelMatrix || !u_MvpMatrix || !u_NormalMatrix || !u_LightColor || !u_LightPosition　 || !u_AmbientLight) {
                console.log('Failed to get the storage location');
                return;
            }*/

            gl.uniform3f(u_LightColor, 1.0, 1.0, 1.0);
  // Set the light direction (in the world coordinate)
            gl.uniform3f(u_LightPosition, 0.0, 0.0, 0.0);
            gl.uniform3f(u_LightDirection, 0.0, -1.0, 0.0);
  // Set the ambient light
            gl.uniform3f(u_AmbientLight, 0.2, 0.2, 0.2);
  // Set the specular color (white)
            gl.uniform3f(u_SpecularColor, 0.8, 0.8, 0.8);
  // Set the ambient light
            gl.uniform1f(u_Exponent, 5.0);


            gl.enableVertexAttribArray(aCoords); // won't change after initialization.
            gl.enableVertexAttribArray(aNormal); // also won't change.
            gl.enable(gl.DEPTH_TEST);
        } catch (e) {
            document.getElementById("message").innerHTML =
                "Could not initialize WebGL: " + e;
            return;
        }


        torus = createModel(uvTorus(0.25, 0.18, 16, 8), [0, 0.17, 0]); // Create all the basic objects.
        sphere = createModel(uvSphere(1));
        cone = createModel(uvCone(0.8, 1.8), [0, 0, 3.0]);
        cylinder = createModel(uvCylinder(0.25, 4.0), [0, 0, 1]);
        disk = createModel(uvCylinder(5.5, 0.5, 64), [0, 0, .25]);
        ring = createModel(ring(3.3, 4.8, 40));
        cube = createModel(cube());

        rotator = new SimpleRotator(canvas, draw);
        rotator.setView([0, 1, 2], [0, 1, 0], 16);
        //setInterval(changeLightLocation,1000);
        setInterval(draw,50);
    }
    </script>
</head>

<body onload="init()" style="background-color:#DDD">
    <p id="message" style="font-weight:bold">Drag your mouse on the model to rotate it.</p>
    <p>
    </p>
    <div>
        <canvas width=800 height=800 id="glcanvas" style="background-color:blue"></canvas>
    </div>
</body>

</html>
