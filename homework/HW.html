<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>HomeWork#1</title>
    <script type="x-shader/x-vertex" id="vshader">      
        attribute vec3 coords;
        attribute vec3 normal;

        uniform mat4 modelview;
        uniform mat4 projection;
        uniform mat3 normalMatrix;
        uniform vec4 color;
        
        varying vec3 v_Position;
        varying vec3 v_Normal;
        varying vec4 v_Color;

        void main() { 
        vec4 coords = vec4(coords,1.0);
        vec4 transformedVertex = modelview * coords;
        gl_Position = projection * transformedVertex;
        v_Position = vec3(transformedVertex);
        v_Normal = normalize(normalMatrix*normal);
        v_Color = color;
        }
    </script>
    <script type="x-shader/x-fragment" id="fshader">
        precision mediump float;
        uniform vec3 u_LightColor;
        uniform vec3 u_LightPosition;
        uniform vec3 u_LightPosition2;
        uniform vec3 u_ViewerPosition;
        uniform vec3 u_SpecularColor;
        uniform float u_Exponent;
        uniform vec3 u_AmbientLight;
        
        varying vec3 v_Normal;
        varying vec3 v_Position;
        varying vec4 v_Color;
        void main() {
                vec3 normal = normalize(v_Normal);
                vec3 lightDirection = normalize(u_LightPosition - v_Position);
                vec3 viewerDirection = -normalize(u_ViewerPosition - v_Position);
                vec3 reflectDirection = normalize(reflect(lightDirection, normal));
            
                float nDotL = max(dot(lightDirection, normal), 0.0);
                float rDotV = pow(max(dot(reflectDirection, viewerDirection), 0.0),u_Exponent);
                vec3 diffuse = u_LightColor * v_Color.rgb * nDotL;
                vec3 specular = u_LightColor * u_SpecularColor.rgb * rDotV ;
                vec3 ambient = u_AmbientLight * v_Color.rgb;
                gl_FragColor = vec4(diffuse + ambient + specular, v_Color.a);
            
        }
    </script>
    <script type="text/javascript" src="gl-matrix.js"></script>
    <script type="text/javascript" src="basic-objects.js"></script>
    <script type="text/javascript" src="simple-rotator.js"></script>
    <script type="text/javascript">
    "use strict";

    var gl; // The webgl context.

    var aCoords; // Location of the coords attribute variable in the shader program.
    var aCoordsBuffer; // Buffer to hold coords.
    var aNormal; // Location of the normal uniform in the shader program.
    var aNormalBuffer; // Buffer to hold normal vectors.
    var indexBuffer; // Buffer to hold indices for gl.drawElements
    var uColor; // Location of the color uniform variable in the shader program.
    var uProjection; // Location of the projection uniform matrix in the shader program.
    var uModelview; // Location of the modelview unifirm matrix in the shader program.
    var uNormalMatrix; // Location of the normalMatrix uniform matrix in the shader program.

    var projection = mat4.create(); // projection matrix
    var modelview = mat4.create(); // modelview matrix
    var normalMatrix = mat3.create(); // matrix, derived from modelview matrix, for transforming normal vectors

    var rotator; // A SimpleRotator object to enable rotation by mouse dragging.

    var frameNumber = 0; // frame number during animation (actually only goes up by 0.5 per frame)

    var torus, sphere, cone, cylinder, disk, ring, cube; // basic objects, created using function createModel

    var show = 1; // When this variable is 1, the entire scene is drawn; when it is 2, only the car is shown

    var modelview; // The current modelview matrix
    var matrixStack = []; // A stack of matrices for implementing hierarchical graphics.

    var currentColor = [1, 1, 1, 1]; // The current drawing color; objects are rendered using this color.

    var r=4.5;
    var angle=0;
    var angle2=0;
    var velocityBycicle1=1;
    var velocityBycicle2=1.5;
    var fact = Math.PI/180;
    var u_LightColor;
    var u_LightPosition;
    var u_SpecularColor;
    //var u_LightColor2;
    //var u_LightPosition2;
    //var u_SpecularColor2;

    /**
     * Draws the image, which consists of either the "world" or a closeup of the "car".
     */
    function draw() {
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(projection, Math.PI / 4, 1, 1, 50); //assigns to the matrix projection the transformation with frustum
        //defined by an eye angle of 45 degrees (pi/4), ratio of width/height
        // of 1, near plane 1 and far plane 50
        gl.uniformMatrix4fv(uProjection, false, projection); //assigns the value of the matrix projection to the uniform matrix uProjection
        modelview = rotator.getViewMatrix();
        //alert(frameNumber);
        var xLight1=(r+0.3)*Math.cos(angle2*fact + 0.3);
        var yLight1=(r+0.3)*Math.sin(angle2*fact + 0.3);
        var zLight1=0.8;
        var light_vector1 = vec4.fromValues(xLight1,zLight1,yLight1,1.0);
        mat4.multiply(light_vector1,modelview,light_vector1);
        gl.uniform3f(u_LightPosition,light_vector1[0],light_vector1[1],light_vector1[2]);
    
        //modelview = rotator.getViewMatrix();
        /*var xLight2=(r-0.3)*Math.cos(angle*fact + 0.3);
        var yLight2=(r-0.3)*Math.sin(angle*fact + 0.3);
        var zLight2=zLight1;
        var light_vector2 = vec4.fromValues(xLight2,zLight2,yLight2,1.0);
        mat4.multiply(light_vector2,modelview,light_vector2);
        gl.uniform3f(u_LightPosition2,light_vector2[0],light_vector2[1],light_vector2[2]);*/
        incrementAngle();
         //computes the modelview from the position of the rotator
        mat3.normalFromMat4(normalMatrix, modelview); //computes the normalMatrix (used to multiply the normals) from the modelview

        if (show == 1)
            world();
        else
            car();
    }

    /**
     * Draws a "world" consisting of a disk holding some trees and a road, and a car that
     * drives along the road.  A tree in the middle grows from frame 0 to frame 1000.
     */
    function world() {
        pushMatrix(); //creates a copy of the current top matrix of the matrix stack
        mat4.translate(modelview, modelview, [0, -0.05, 0]); //modifies the second parameter (modelview) by multiplying it with
        //the translation matrix with parameters [0,-0.05,0] and assigns the result
        //to the first parameter. In this case, it modifies the modelview.
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [1, 0, 0]); //modifies the second parameter (modelview) by multiplying it with
        //the rotation matrix with parameters (90)/180*Math.PI (angle of 90 degrees) and
        //[1,0,0] (axis of rotation) and assigns the result
        //to the first parameter. In this case, it modifies the modelview.
        currentColor = [0.1, 0.4, 0.1, 1]; //Defines the color
        disk.render(); //Renders the disk
        popMatrix(); //deletes the top matrix of the stack
        pushMatrix();
        currentColor = [0.7, 0.7, 0.8, 1];

        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [-1, 0, 0]);
        ring.render();
        popMatrix();

        //bicycle 1
        pushMatrix();
        var bicycle1X = Math.cos(angle2*fact)*r;
        var bicycle1Y = Math.sin(angle2*fact)*r;
        mat4.translate(modelview, modelview, [bicycle1X, 0, bicycle1Y]);
        mat4.rotate(modelview, modelview, Math.atan2(bicycle1X,bicycle1Y), [0, 1, 0]);
        mat4.scale(modelview, modelview, [0.4, 0.4, 0.4]);
        bicycle();
        popMatrix();

        //bicycle 2
        pushMatrix();
        var bicycle2X = Math.cos(angle*fact)*(r-1);
        var bicycle2Y = Math.sin(angle*fact)*(r-1);
        mat4.translate(modelview, modelview, [bicycle2X, 0, bicycle2Y]);
        mat4.rotate(modelview, modelview, Math.atan2(bicycle2X,bicycle2Y), [0, 1, 0]);
        mat4.scale(modelview, modelview, [0.4, 0.4, 0.4]);
        bicycle();
        popMatrix();

        /*bike for testing purposes
        pushMatrix();
        mat4.scale(modelview, modelview, [1, 1, 1]);
        bicycle();
        popMatrix();
        */

        //4 trees
        pushMatrix();
        mat4.translate(modelview, modelview, [5.3, 0, 0]);
        mat4.scale(modelview, modelview, [0.7, 0.7, 0.7]);
        tree();
        popMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [1.4, 0, 2]);
        mat4.scale(modelview, modelview, [0.7, 0.7, 0.7]);
        tree();
        popMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [2.3, 0, -2]);
        mat4.scale(modelview, modelview, [0.7, 0.7, 0.7]);
        tree();
        popMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [3.8, 0, 2.5]);
        mat4.scale(modelview, modelview, [0.7, 0.7, 0.7]);
        tree();
        popMatrix();
        popMatrix();
    }


    function incrementAngle(){
      if (angle == 359) {
              angle = 0;
            }
      else angle+=velocityBycicle1;    

      if (angle2 >= 359) {
              angle2 = 0;
            }
      else angle2+=velocityBycicle2;     
    }

    /**
     * Draws a tree consisting of a green cone with a brown cylinder for a trunk.
     */
    function tree() {
        pushMatrix();
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [-1, 0, 0]);
        pushMatrix();
        mat4.translate(modelview, modelview, [-5.3, 0, 0]);
        mat4.scale(modelview, modelview, [0.5, 0.5, 4]);
        currentColor = [0.5, 0.3, 0.1, 1];
        cylinder.render();
        popMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [-1.5, 0, 4]);
        mat4.scale(modelview, modelview, [1.9, 1.9, 2.7]);
        currentColor = [0, 0.8, 0, 1];
        cone.render();
        popMatrix();
        popMatrix();
    }

    /**
     * Draws a bicycle consisting of a (simplified) body, two wheels 
     * and a light positioned in front.
     */
    function bicycle() {
        pushMatrix();
        mat4.translate(modelview, modelview, [0, 0.7, 0]);
        wheel();
        popMatrix();
        pushMatrix();
        mat4.translate(modelview, modelview, [-2.8, 0.7, 0]);
        wheel();
        popMatrix();
        //Setting all structure
        pushMatrix();
        currentColor = [1.0, 0.5, 0.0, 1];
        mat4.translate(modelview, modelview, [-0.4, -0.02, 0])
            //First orizontal cylinder
        pushMatrix();
        mat4.translate(modelview, modelview, [-2.3, 2.2, 0]);
        mat4.scale(modelview, modelview, [2.0, 0.2, 0.2]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [0, 1, 0]);
        cylinder.render();
        popMatrix();
        //Second orizontal cylinder
        pushMatrix();
        mat4.translate(modelview, modelview, [-1.65, 1.5, 0]);
        mat4.scale(modelview, modelview, [2.1, 0.2, 0.2]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [0, 1, 0]);
        cylinder.render();
        popMatrix();
        //First oblique cylinder
        pushMatrix();
        mat4.translate(modelview, modelview, [-2.3, 2.2, 0]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [1, 1, 0]);
        mat4.scale(modelview, modelview, [.2, 0.2, 1.0]);
        cylinder.render();
        popMatrix();
        //Second oblique cylinder
        pushMatrix();
        mat4.translate(modelview, modelview, [-0.3, 2.2, 0]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [1, 1, 0]);
        mat4.scale(modelview, modelview, [.2, 0.2, 1.0]);
        cylinder.render();
        popMatrix();

        //Saddle cylinder
        pushMatrix();
        mat4.translate(modelview, modelview, [-0.3, 2.4, 0]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [1, 0, 0]);
        mat4.scale(modelview, modelview, [.2, 0.2, 0.9]);
        cylinder.render();
        popMatrix();
        //cylinder handlebars
        pushMatrix();
        mat4.translate(modelview, modelview, [-2.3, 2.6, 0]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [1, 0, 0]);
        mat4.scale(modelview, modelview, [.2, 0.2, 1.1]);
        cylinder.render();
        popMatrix();
        //saddle
        pushMatrix();
        currentColor = [0.2, 0.2, 0.6, 1];
        mat4.translate(modelview, modelview, [-0.5, 2.5, 2.0]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [0, -1, 0]);
        mat4.scale(modelview, modelview, [1, 0.2, 1]);
        cone.render();
        popMatrix();
        //handlebars
        pushMatrix();
        currentColor = [0.2, 0.2, 0.6, 1];
        mat4.translate(modelview, modelview, [-2.3, 2.6, -0.6]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [0, 0, 1]);
        mat4.scale(modelview, modelview, [.2, 0.2, 1.2]);
        cylinder.render();
        popMatrix();
         //light ext
        pushMatrix();
        currentColor = [1,1,0,1];
        mat4.translate(modelview, modelview, [-2.4, 2.2, -0.9]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [0, 1, 0]);
        mat4.scale(modelview, modelview, [0.45, 0.45, 0.2]);
        cone.render();
        popMatrix();
        //light ext2
        pushMatrix();
        currentColor = [0.839216,0.839216,0.839216,1];
        mat4.translate(modelview, modelview, [-2.5, 2.2, 0]);
        mat4.rotate(modelview, modelview, (90) / 180 * Math.PI, [0, 1, 0]);
        mat4.scale(modelview, modelview, [0.3, 0.3, 0.3]);
        torus.render();
        popMatrix();
        //end structure
        popMatrix();

    }

    /**
     * Draw a rotating wheel that consists of a torus to make the wheel.
     */
    function wheel() {
        pushMatrix();
        currentColor = [0.2, 0.2, 0.3, 1];
        mat4.scale(modelview, modelview, [0.8, 0.8, 0.8]);
        torus.render();
        popMatrix();
    }


    /**
     *  Push a copy of the current modelview matrix onto the matrix stack.
     */
    function pushMatrix() {
        matrixStack.push(mat4.clone(modelview));
    }

    /**
     *  Restore the modelview matrix to a value popped from the matrix stack.
     */
    function popMatrix() {
        modelview = matrixStack.pop();
    }


    /**
     *  Create one of the basic objects.  The modelData holds the data for
     *  an IFS using the structure from basic-objects-IFS.js.  This function
     *  creates VBOs to hold the coordinates, normal vectors, and indices
     *  from the IFS, and it loads the data into those buffers.  The function
     *  creates a new object whose properties are the identifies of the
     *  VBOs.  The new object also has a function, render(), that can be called to
     *  render the object, using all the data from the buffers.  That object
     *  is returned as the value of the function.  (The second parameter,
     *  xtraTranslate, is there because this program was ported from a Java
     *  version where cylinders were created in a different position, with
     *  the base on the xy-plane instead of with their center at the origin.
     *  The xtraTranslate parameter is a 3-vector that is applied as a
     *  translation to the rendered object.  It is used to move the cylinders
     *  into the position expected by the code that was ported from Java.)
     */
    function createModel(modelData, xtraTranslate) {
        var model = {};
        model.coordsBuffer = gl.createBuffer();
        model.normalBuffer = gl.createBuffer();
        model.indexBuffer = gl.createBuffer();
        model.count = modelData.indices.length;
        if (xtraTranslate)
            model.xtraTranslate = xtraTranslate;
        else
            model.xtraTranslate = null;
        gl.bindBuffer(gl.ARRAY_BUFFER, model.coordsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexPositions, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexNormals, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, modelData.indices, gl.STATIC_DRAW);
        model.render = function() { // This function will render the object.
            // Since the buffer from which we are taking the coordinates and normals
            // change each time an object is drawn, we have to use gl.vertexAttribPointer
            // to specify the location of the data. And to do that, we must first
            // bind the buffer that contains the data.  Similarly, we have to
            // bind this object's index buffer before calling gl.drawElements.
            gl.bindBuffer(gl.ARRAY_BUFFER, this.coordsBuffer);
            gl.vertexAttribPointer(aCoords, 3, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
            gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);
            gl.uniform4fv(uColor, currentColor);
            if (this.xtraTranslate) {
                pushMatrix();
                mat4.translate(modelview, modelview, this.xtraTranslate);
            }
            gl.uniformMatrix4fv(uModelview, false, modelview);
            mat3.normalFromMat4(normalMatrix, modelview);
            gl.uniformMatrix3fv(uNormalMatrix, false, normalMatrix);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);
            if (this.xtraTranslate) {
                popMatrix();
            }
        }
        return model;
    }



    /* Creates a program for use in the WebGL context gl, and returns the
     * identifier for that program.  If an error occurs while compiling or
     * linking the program, an exception of type String is thrown.  The error
     * string contains the compilation or linking error.  If no error occurs,
     * the program identifier is the return value of the function.
     */
    function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
        var vsh = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vsh, vertexShaderSource);
        gl.compileShader(vsh);
        if (!gl.getShaderParameter(vsh, gl.COMPILE_STATUS)) {
            throw "Error in vertex shader:  " + gl.getShaderInfoLog(vsh);
        }
        var fsh = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fsh, fragmentShaderSource);
        gl.compileShader(fsh);
        if (!gl.getShaderParameter(fsh, gl.COMPILE_STATUS)) {
            throw "Error in fragment shader:  " + gl.getShaderInfoLog(fsh);
        }
        var prog = gl.createProgram();
        gl.attachShader(prog, vsh);
        gl.attachShader(prog, fsh);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            throw "Link error in program:  " + gl.getProgramInfoLog(prog);
        }
        return prog;
    }


    /* Gets the text content of an HTML element.  This is used
     * to get the shader source from the script elements that contain
     * it.  The parameter should be the id of the script element.
     */
    function getTextContent(elementID) {
        var element = document.getElementById(elementID);
        var fsource = "";
        var node = element.firstChild;
        var str = "";
        while (node) {
            if (node.nodeType == 3) // this is a text node
                str += node.textContent;
            node = node.nextSibling;
        }
        return str;
    }


    //--------------------------------- animation framework ------------------------------

    window.requestAnimationFrame =
        window.requestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        function(callback) {
            setTimeout(function() {
                callback(Date.now());
            }, 1000 / 60);
        }

    var animating = true;

    function frame() {
        if (animating) {
            frameNumber += 0.5;
            draw();
            requestAnimationFrame(frame);
        }
    }

    function setAnimating(run) {
        if (run != animating) {
            animating = run;
            if (animating)
                requestAnimationFrame(frame);
        }
    }

    //-------------------------------------------------------------------------

    function init() {
        try {
            var canvas = document.getElementById("glcanvas");
            gl = canvas.getContext("webgl");
            if (!gl) {
                gl = canvas.getContext("experimental-webgl");
            }
            if (!gl) {
                throw "Could not create WebGL context.";
            }
            var vertexShaderSource = getTextContent("vshader");
            var fragmentShaderSource = getTextContent("fshader");
            var prog = createProgram(gl, vertexShaderSource, fragmentShaderSource);
            gl.useProgram(prog);
            aCoords = gl.getAttribLocation(prog, "coords");
            aNormal = gl.getAttribLocation(prog, "normal");
            uModelview = gl.getUniformLocation(prog, "modelview");
            uProjection = gl.getUniformLocation(prog, "projection");
            uColor = gl.getUniformLocation(prog, "color");
            uNormalMatrix = gl.getUniformLocation(prog, "normalMatrix");


                u_LightColor = gl.getUniformLocation(prog, "u_LightColor");
                var u_ViewerPosition = gl.getUniformLocation(prog, "u_ViewerPosition");
                u_SpecularColor = gl.getUniformLocation(prog, "u_SpecularColor");
                var u_Exponent = gl.getUniformLocation(prog, "u_Exponent");
                u_LightPosition = gl.getUniformLocation(prog, "u_LightPosition");
                var u_AmbientLight = gl.getUniformLocation(prog, "u_AmbientLight");
                //u_LightColor2 = gl.getUniformLocation(prog, "u_LightColor[1]");
                //u_SpecularColor2 = gl.getUniformLocation(prog, "u_SpecularColor[1]");   
                //u_LightPosition2 = gl.getUniformLocation(prog, "u_LightPosition[1]");
                
                gl.uniform3f(u_ViewerPosition,0,0,0);
                gl.uniform3f(u_LightColor,0.8,0.8,0.8);
                //gl.uniform3f(u_LightColor2,0,0,0);
                // Set the light direction (in the world coordinate)
                //gl.uniform3f(u_LightPosition,-3.0,-1.0, 10.0);
                //gl.uniform3f(u_LightPosition2,-3.0,-1.0, 10.0);
                //gl.uniform3f(u_LightPosition2, 0, 14.5, 0);
                // Set the ambient light
                gl.uniform3f(u_AmbientLight, 0.2, 0.2, 0.2);
                // Set the specular color (white)
                gl.uniform3f(u_SpecularColor,0.4, 0.4, 0.4);
                //gl.uniform3f(u_SpecularColor2,0.4, 0.4, 0.4);
                // Set the ambient light
                gl.uniform1f(u_Exponent,3);


            gl.enableVertexAttribArray(aCoords); // won't change after initialization.
            gl.enableVertexAttribArray(aNormal); // also won't change.
            gl.enable(gl.DEPTH_TEST);
        } catch (e) {
            document.getElementById("message").innerHTML =
                "Could not initialize WebGL: " + e;
            return;
        }

        torus = createModel(uvTorus(0.65, 1, 16, 8)); // Create all the basic objects.
        sphere = createModel(uvSphere(100));
        cone = createModel(uvCone(), [-2, 0, 0]);
        cylinder = createModel(uvCylinder(), [0, 0, .5]);
        disk = createModel(uvCylinder(5.5, 0.5, 64), [0, 0, .25]);
        ring = createModel(ring(3.3, 4.8, 40));
        cube = createModel(cube());

        rotator = new SimpleRotator(canvas, draw);
        rotator.setView([0, 1, 2], [0, 1, 0], 16);
        frame();
    }
    </script>
</head>

<body onload="init()" style="background-color:#DDD">
    <p id="message" style="font-weight:bold">Drag your mouse on the model to rotate it.</p>
    <p>
    </p>
    <div>
        <canvas width=800 height=800 id="glcanvas" style="background-color:blue"></canvas>
    </div>
</body>

</html>
